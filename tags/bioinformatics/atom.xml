<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Mostly Programming - Bioinformatics</title>
	<subtitle>Programming, Bioinformatics, Data, Books, and More</subtitle>
	<link href="https://njagi.me/tags/bioinformatics/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://njagi.me"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2019-08-20T00:00:00+00:00</updated>
	<id>https://njagi.me/tags/bioinformatics/atom.xml</id>
	<entry xml:lang="en">
		<title>Google Summer of Code 2019—Final Submission</title>
		<published>2019-08-20T00:00:00+00:00</published>
		<updated>2019-08-20T00:00:00+00:00</updated>
		<link href="https://njagi.me/posts/google-summer-of-code-2019-final-submission/" type="text/html"/>
		<id>https://njagi.me/posts/google-summer-of-code-2019-final-submission/</id>
		<content type="html">&lt;p&gt;The Google Summer of Code for 2019 is coming to a close. I&#x27;ve been working on
the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;Graphite&lt;&#x2F;a&gt; project aimed at creating a variation graph tool under the
&lt;a href=&quot;https:&#x2F;&#x2F;www.open-bio.org&quot;&gt;Open Bioinformatics Foundation&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;genome-graphs&quot;&gt;Genome Graphs&lt;&#x2F;h1&gt;
&lt;p&gt;I shall give an overview of genome graphs; for a more thorough introduction, I
advise reading  &lt;a href=&quot;https:&#x2F;&#x2F;lh3.github.io&#x2F;2019&#x2F;07&#x2F;08&#x2F;on-a-reference-pan-genome-model&quot;&gt;On a reference pan-genome model&lt;&#x2F;a&gt; or my very own
&lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;google-summer-of-code-2019-final-submission&#x2F;2019-06-22-Introduction-to-Variation-Graphs.html&quot;&gt;An Introduction to Variation Graphs&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ekg.github.io&#x2F;2019&#x2F;07&#x2F;09&#x2F;Untangling-graphical-pangenomics&quot;&gt;Variation graphs&lt;&#x2F;a&gt; are a class of &lt;a href=&quot;https:&#x2F;&#x2F;www.biorxiv.org&#x2F;content&#x2F;10.1101&#x2F;101378v1&quot;&gt;genome graphs&lt;&#x2F;a&gt; that, among other things,
maintain:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;path information—a full walk within the graph along the edges&lt;&#x2F;li&gt;
&lt;li&gt;a strong mapping between nodes on the graph and their positions on the
reference&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;All this with the main aim of representing genomic variation.&lt;&#x2F;p&gt;
&lt;p&gt;Currently genomes are represented as a consensus; for example, here&#x27;s part of
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&#x2F;blob&#x2F;master&#x2F;test&#x2F;1mb1kgp&#x2F;z.fa&quot;&gt;chromosome 20 of the human genome&lt;&#x2F;a&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;TGGGAGAGAACTGGAACAAGAACCCAGTGCTCTTTCTGCTCTACCCACTGACCCATCCTCTCACGCATCATACACCCATA
&lt;&#x2F;span&gt;&lt;span&gt;CTCCCATCCACCCACCTTCCCATTCATGCATTCACCCATTCACCCACCTTCCATCCATCTACCATCCACCACGTACCTAC
&lt;&#x2F;span&gt;&lt;span&gt;ACTCCCATCTACCATCCAACCACATTTCCATTCACCCATCCTCCCATCCATCAACCCTCCAATCCACCACCCACAGACCT
&lt;&#x2F;span&gt;&lt;span&gt;TCCCATCCATTCATTTACCCATCCACATATTCACCCACCCTCCCATCCATCCATCTACTGTCTATCACCTACTCATTTTC
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, variation &lt;strong&gt;does&lt;&#x2F;strong&gt; exist on this chromosome between individuals.
To demonstrate, when &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&#x2F;blob&#x2F;master&#x2F;test&#x2F;1mb1kgp&#x2F;z.vcf.gz&quot;&gt;a single file of variation data&lt;&#x2F;a&gt; is &amp;quot;applied&amp;quot; to it we end
up with a graph that can be represented as in the  below zoomed in section of
chromosome 20.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;chr20.png&quot; alt=&quot;chr20&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Not all graphs are linear like the one above; in fact, the kind of graphs we&#x27;re
hoping to generate soon will have many breaks and will look pretty jumbled up.
The amount of variation within and between genomes depends on a lot of factors
including but not limited to the organism(s) whose genomes are studying and how
evolutionarily distant the genomes we are comparing are (pan-genomes).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;reference-bias&quot;&gt;Reference Bias&lt;&#x2F;h2&gt;
&lt;p&gt;The reference being a consensus introduces a problem known as &lt;a href=&quot;https:&#x2F;&#x2F;www.sevenbridges.com&#x2F;reference-bias-challenges-and-solutions&#x2F;&quot;&gt;reference bias&lt;&#x2F;a&gt;;
which is analogous to a false negative during read mapping, that is, claiming
that a variation does not exist where it actually exists.
&lt;a href=&quot;https:&#x2F;&#x2F;www.nature.com&#x2F;articles&#x2F;nbt.4227&quot;&gt;Research&lt;&#x2F;a&gt; has shown an improvement in read mapping of short read data when
short reads are mapped to a reference graph instead of a reference consensus.&lt;&#x2F;p&gt;
&lt;p&gt;Currently, graphite shows that we can generate a graph from a reference and
variation data and progressively update it; not far from what Heng Li theorizes
in: &lt;a href=&quot;https:&#x2F;&#x2F;lh3.github.io&#x2F;2019&#x2F;07&#x2F;08&#x2F;on-a-reference-pan-genome-model&quot;&gt;On a reference pan-genome model&lt;&#x2F;a&gt;.
We plan on supporting the generation of graphs from short and long-read data on
its own (de novo), you can track its progress under
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&#x2F;projects&#x2F;1&quot;&gt;the alignment project board&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;why-racket&quot;&gt;Why Racket?&lt;&#x2F;h1&gt;
&lt;p&gt;You may wonder why Graphite is written in Racket yet the project name is
&lt;a href=&quot;https:&#x2F;&#x2F;summerofcode.withgoogle.com&#x2F;projects&#x2F;#4733198808907776&quot;&gt;Add Variant Graph (VG) support to BioD&lt;&#x2F;a&gt;.
Genome graphs have been theorized and written about for a while now but there
are only a few tools that implement them and there has been even much less use
by bioinformaticians.&lt;&#x2F;p&gt;
&lt;p&gt;We decided to build something people can use over just adding variation graph
support to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;biod&#x2F;biod&quot;&gt;BioD&lt;&#x2F;a&gt; believing that it would&#x27;ve taken me longer to write something
people could use in D.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;why-racket-not-another-language-or-lisp&quot;&gt;Why Racket Not Another Language or Lisp?&lt;&#x2F;h2&gt;
&lt;p&gt;I have experience in functional programming and particularly
professional experience with LISPs, I could, therefore, move much faster in it.
Racket is a good LISP to use when working in an unfamiliar domain because it has
a &lt;strong&gt;straightforward build system&lt;&#x2F;strong&gt; compared to the overhead of the JVM and
leiningen in the most popular LISP, Clojure does and has an
&lt;strong&gt;easy to use C&#x2F;C++ FFI&lt;&#x2F;strong&gt;, languages used in a lot of Bioinformatics
applications and libraries. Being &lt;strong&gt;untyped&lt;&#x2F;strong&gt; and programming in LISP being
&lt;strong&gt;REPL driven&lt;&#x2F;strong&gt; also helps to venture into unfamiliar territory.
Racket has &lt;strong&gt;immutability&lt;&#x2F;strong&gt; in a lot, if not all, of its data structures which
also helps with all the data manipulation we would have to do. Finally, Racket
also &lt;strong&gt;implements core programming concepts elegantly&lt;&#x2F;strong&gt; compared to many other
languages for example with its hygienic macros.&lt;&#x2F;p&gt;
&lt;p&gt;This shouldn&#x27;t make the D community feel betrayed because given what
we know now, we can always go back and reimplement either all or part of
Graphite in D, especially for the possible performance improvements.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;done&quot;&gt;Done&lt;&#x2F;h1&gt;
&lt;p&gt;For the fine detail install and set up Graphite as instructed in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite#graphite&quot;&gt;README&lt;&#x2F;a&gt;
and run &lt;code&gt;graphite --help&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;underlying-graph-representation&quot;&gt;Underlying Graph Representation&lt;&#x2F;h2&gt;
&lt;p&gt;We implemented the graph as an association hash table. I went into more detail
on how it&#x27;s built and the rationale behind certain choices in
&lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;google-summer-of-code-2019-final-submission&#x2F;2019-07-15-Creating-the-Initial-Variation-Graph.html&quot;&gt;Creating the Initial Variation Graph&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;google-summer-of-code-2019-final-submission&#x2F;2019-07-21-Justifying-SHA256-in-Graphite.html&quot;&gt;Justifying SHA256 in Graphite&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;construct&quot;&gt;Construct&lt;&#x2F;h2&gt;
&lt;p&gt;Graphite allows you to build an initial graph out of a reference in
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FASTA_format&quot;&gt;FASTA format&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Variant_Call_Format&quot;&gt;VCF&lt;&#x2F;a&gt; file.
In the example below I output a serialized graph but you can output &lt;code&gt;.dot&lt;&#x2F;code&gt; or
&lt;code&gt;.gfa&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;.&#x2F;bin&#x2F;graphite construct \
&lt;&#x2F;span&gt;&lt;span&gt; -o rsv1.gra \
&lt;&#x2F;span&gt;&lt;span&gt; -f gra \
&lt;&#x2F;span&gt;&lt;span&gt; data&#x2F;RSV&#x2F;refererence_and_vcf_file&#x2F;9465113.fa data&#x2F;RSV&#x2F;refererence_and_vcf_file&#x2F;H_3801_22_04.freebayes.vcf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;update&quot;&gt;Update&lt;&#x2F;h2&gt;
&lt;p&gt;Formally, &lt;em&gt;progressive construction&lt;&#x2F;em&gt;. Graphite lets the user update a serialized
graph generated via &lt;code&gt;construct&lt;&#x2F;code&gt;.
In the update, it takes serialized graph &lt;code&gt;.gra&lt;&#x2F;code&gt; and variation data in VCF.
Example:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;.&#x2F;bin&#x2F;graphite update \
&lt;&#x2F;span&gt;&lt;span&gt; -o rsv2.dot \
&lt;&#x2F;span&gt;&lt;span&gt; -f dot \
&lt;&#x2F;span&gt;&lt;span&gt; rsv1.gra data&#x2F;RSV&#x2F;refererence_and_vcf_file&#x2F;fake_H_3801_22_04.freebayes.vcf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;view&quot;&gt;View&lt;&#x2F;h2&gt;
&lt;p&gt;Graphite allows you to generate graphs in&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dot&lt;&#x2F;strong&gt; for visualization via &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graphviz&quot;&gt;GraphViz&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;gfa&lt;&#x2F;strong&gt; for visualization with tools like &lt;a href=&quot;https:&#x2F;&#x2F;rrwick.github.io&#x2F;Bandage&#x2F;&quot;&gt;bandage&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;gra&lt;&#x2F;strong&gt; a serialized graph, it can&#x27;t be visualized.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Using &lt;code&gt;update&lt;&#x2F;code&gt; and &lt;code&gt;view&lt;&#x2F;code&gt;, one can visualize changes introduced by different VCF
files as of writing this.
The view command takes a serialized graph &lt;code&gt;.gra&lt;&#x2F;code&gt;, an output format, and an output
file as arguments.
Example:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;.&#x2F;bin&#x2F;graphite view \
&lt;&#x2F;span&gt;&lt;span&gt; -o rsv1.dot \
&lt;&#x2F;span&gt;&lt;span&gt; -f dot \
&lt;&#x2F;span&gt;&lt;span&gt; rsv1.gra
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;to-do&quot;&gt;To Do&lt;&#x2F;h1&gt;
&lt;p&gt;Look at the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&#x2F;projects&quot;&gt;Graphite project boards&lt;&#x2F;a&gt; for further detail.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;partial-order-alignment&quot;&gt;Partial Order Alignment&lt;&#x2F;h2&gt;
&lt;p&gt;This would allow for aligning reads to a graph or against each other bypassing
the consensus reference.&lt;&#x2F;p&gt;
&lt;p&gt;For now, graphite can only align against strings (however this functionality
isn&#x27;t exposed because it&#x27;s not ready yet) mainly because it only
stores forward edges which makes it hard to implement
Partial Order Alignment (POA) which strictly depends on backward edges.
The short term options are adding a pre-processing
step to generate backward edges or using Racket&#x27;s FFI to call &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rvaser&#x2F;spoa&quot;&gt;spoa&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;gssw&quot;&gt;gssw&lt;&#x2F;a&gt;.
In the medium to long term Graphite&#x27;s nodes should support backward edges which
would, on top of assisting with POA, allow for encoding more complex mutations
such as inversions.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;search&quot;&gt;Search&lt;&#x2F;h2&gt;
&lt;p&gt;This involves having a kmer, the substring of a genome, and searching for its
most likely position in the graph.
I have multiple problems with this as of now such as completely not finding
kmers at all or having them point to the wrong location.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;complementarity&quot;&gt;Complementarity&lt;&#x2F;h3&gt;
&lt;p&gt;Graphite doesn&#x27;t support complementarity (only supports the positive strands)
therefore searching for a kmer in the negative strand wouldn&#x27;t even work.
I am evaluating different ways of implementing complementarity.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-graph-extension-of-the-burrows-wheeler-transform&quot;&gt;A Graph Extension of the Burrows-Wheeler Transform&lt;&#x2F;h3&gt;
&lt;p&gt;Search doesn&#x27;t work for some strings and even worse the method I am using to
build the index is not ideal. Currently, I am building the FM index via a
Burrows-Wheeler Transform (BWT) which is in turn built from rotating the given
string, this is far from ideal.
A better strategy I am considering is:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;generate a suffix tree via &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ukkonen%27s_algorithm&quot;&gt;Ukkonen&#x27;s algorithm&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;traverse the suffix tree via a depth-first search to build a suffix array&lt;&#x2F;li&gt;
&lt;li&gt;use the suffix array to generate a BWT&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;I could then complement the BWT and then generate the FM index and therefore
get fast queries onto the graph.
I believe this to be the basic idea behind
&lt;a href=&quot;https:&#x2F;&#x2F;www.biorxiv.org&#x2F;content&#x2F;10.1101&#x2F;051409v1&quot;&gt;A Graph Extension of the Positional Burrows-Wheeler Transform and its Applications&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;adding-a-metadata-field&quot;&gt;Adding a Metadata Field&lt;&#x2F;h2&gt;
&lt;p&gt;We could add a metadata field to the nodes which will allow for something
like inbuilt annotation support.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;miscellaneous&quot;&gt;Miscellaneous&lt;&#x2F;h2&gt;
&lt;p&gt;Another feature not related to Bioinformatics but is surprisingly lacking in Racket
is to extend &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;racket&#x2F;racket&#x2F;blob&#x2F;master&#x2F;racket&#x2F;collects&#x2F;racket&#x2F;cmdline.rkt&quot;&gt;cmdline&lt;&#x2F;a&gt; to have command-line options as is described in
&lt;a href=&quot;https:&#x2F;&#x2F;pavpanchekha.com&#x2F;blog&#x2F;multi-command-line.html&quot;&gt;Multi-command-line in Racket&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To reiterate, you can look at these 3 other posts regarding Graphite:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;google-summer-of-code-2019-final-submission&#x2F;2019-06-22-Introduction-to-Variation-Graphs.html&quot;&gt;An Introduction to Variation Graphs&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;google-summer-of-code-2019-final-submission&#x2F;2019-07-15-Creating-the-Initial-Variation-Graph.html&quot;&gt;Creating the Initial Variation Graph&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;google-summer-of-code-2019-final-submission&#x2F;2019-07-21-Justifying-SHA256-in-Graphite.html&quot;&gt;Justifying SHA256 in Graphite&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;&#x2F;h1&gt;
&lt;p&gt;I&#x27;d like to acknowledge the contribution of the following organizations and people.&lt;&#x2F;p&gt;
&lt;p&gt;Sponsors:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;summerofcode.withgoogle.com&quot;&gt;Google Summer of Code&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.open-bio.org&quot;&gt;Open Bioinformatics Foundation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;my mentors:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;george-githinji&quot;&gt;George Githinji&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;pjotrp&quot;&gt;Pjotr Prins&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;and those who weren&#x27;t my mentors but helped along the way by offering
technical advice, testing graphite, reading the code or reviewing the blog posts:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;alanorth&quot;&gt;Alan Orth&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ekg&quot;&gt;Erik Garrison&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jasonrogena&quot;&gt;Jason Rogena&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;hipstermojo&quot;&gt;Kenneth Gitere&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kevthanewversi&quot;&gt;Kevin Murimi&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Jusifying SHA256 in Graphite</title>
		<published>2019-07-21T00:00:00+00:00</published>
		<updated>2019-07-21T00:00:00+00:00</updated>
		<link href="https://njagi.me/posts/justifying-sha256-in-graphite/" type="text/html"/>
		<id>https://njagi.me/posts/justifying-sha256-in-graphite/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;Graphite&#x27;s&lt;&#x2F;a&gt; underlying graph implementation is an adjacency hash table, a
complicated way of saying that graphite uses a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hash_table&quot;&gt;hash table&lt;&#x2F;a&gt; to implement the
graph. The keys of the hash table are SHA256 hashes of the concatenation of: the
&lt;em&gt;sequence&lt;&#x2F;em&gt;, a &lt;em&gt;plus symbol(+)&lt;&#x2F;em&gt;, and the &lt;em&gt;offset&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Hashes also grant us outgoing edge representations, constant time lookups for
queries of known sequence and position, and eliminate duplicates.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;computational-cost-of-hashing&quot;&gt;Computational Cost of Hashing&lt;&#x2F;h1&gt;
&lt;p&gt;We have to compute a hash to uniquely identify each variation and we have to
store each hash twice: first, as a &lt;em&gt;key&lt;&#x2F;em&gt; in the adjacency hash table; and second,
as  a field in the variation &lt;code&gt;structure&lt;&#x2F;code&gt; &lt;em&gt;value&lt;&#x2F;em&gt;.
We must therefore examine the time and space costs of hashing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;time&quot;&gt;Time&lt;&#x2F;h2&gt;
&lt;p&gt;I couldn&#x27;t find any useful cost data on either the &lt;a href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;sha&#x2F;index.html&quot;&gt;SHA-2 racket implementation&lt;&#x2F;a&gt;
or &lt;a href=&quot;https:&#x2F;&#x2F;nvlpubs.nist.gov&#x2F;nistpubs&#x2F;FIPS&#x2F;NIST.FIPS.180-4.pdf&quot;&gt;SHA-2&lt;&#x2F;a&gt;, the algorithm itself, but being a string algorithm you can assume
it works in O(n) time, n being the length of the string being hashed.&lt;&#x2F;p&gt;
&lt;p&gt;This isn&#x27;t worrying because hashing is a one off cost which has proved
inexpensive with the current variation data-set.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;space&quot;&gt;Space&lt;&#x2F;h2&gt;
&lt;p&gt;This is more of a concern because we expect graphs to grow with time.&lt;&#x2F;p&gt;
&lt;p&gt;A SHA 256 hash takes the same amount of space as a 32 characters string
(8*32=256). Therefore, for variations with sequences fewer than 32 nucleotides,
we store a hash that is larger than the variation we are hashing
(ignoring the plus symbol and offset). This is exemplified in SNP data.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;graph-comparison&quot;&gt;Graph Comparison&lt;&#x2F;h2&gt;
&lt;p&gt;A nice effect from hashing is that we can compare simple graphs derived from the
same reference by comparing their hashes. It goes without saying that there are
better or more general ways to perform graph comparison.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;probability-of-collision&quot;&gt;Probability of Collision&lt;&#x2F;h1&gt;
&lt;p&gt;We can approximate the probability of a collision using the function
P(n) = 1-e&lt;sup&gt;-n&lt;sup&gt;2&lt;&#x2F;sup&gt;&#x2F;(2d)&lt;&#x2F;sup&gt;. Where &lt;em&gt;n is the sample size&lt;&#x2F;em&gt; and &lt;em&gt;d
is the total number of &amp;quot;buckets&amp;quot;&lt;&#x2F;em&gt;.
For more about calculating this probability check out &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Birthday_problem#Approximations&quot;&gt;Birthday Problem Approximations&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid a collision we need to make sure that our variations are fewer than the
square root of the bucket size—the point at which we get 0.5 chance of having
two different strings sharing the same hash.
Think of it as the halfway point in a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Binomial_distribution&quot;&gt;binomial distribution&lt;&#x2F;a&gt; where past 0.5 we
consider a collision to have occurred. In reality the halfway point occurs
&lt;strong&gt;above&lt;&#x2F;strong&gt; the square root but it&#x27;s still an easy way of verifying that your
sample size is within a safe range.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s a Racket function derived from the one above that I used to approximate
collision probability.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;(define (probability-of-collision  d n)
&lt;&#x2F;span&gt;&lt;span&gt;  (- 1 (&#x2F; 1 (exp (&#x2F; (expt n 2) (* 2 d))))))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-birthday-paradox&quot;&gt;The Birthday Paradox&lt;&#x2F;h2&gt;
&lt;p&gt;Using the approximation function above, we estimate that for every group of 23
randomly selected people (n=23, d=356), the probability that two of them share a
birthday is 0.5; and in a sample of 357 people (n=357, d=356), the probability
that two of them share a birthday is 1.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;birthday.png&quot; alt=&quot;birthday plot&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sha-256&quot;&gt;SHA 256&lt;&#x2F;h2&gt;
&lt;p&gt;For SHA 256 the halfway probability of a hash collision occurs at a point above
2&lt;sup&gt;128&lt;&#x2F;sup&gt;
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;sha256.png&quot; alt=&quot;sha256 plot&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;This may be hard to interpret because exponential functions grow very quickly.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the Racket code I used to generate these plots:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;#lang racket
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(require plot)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(define (probability-of-collision  d x)
&lt;&#x2F;span&gt;&lt;span&gt;  (- 1 (&#x2F; 1 (exp (&#x2F; (expt x 2) (* 2 d))))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(define (label-point-at x y)
&lt;&#x2F;span&gt;&lt;span&gt;  (let* ([fn (lambda (v) (if (&amp;gt; v (expt 10 6)) &amp;#39;exponential &amp;#39;positional))]
&lt;&#x2F;span&gt;&lt;span&gt;        [x* (~r #:precision 4 #:notation fn x)]
&lt;&#x2F;span&gt;&lt;span&gt;        [y* (~r #:precision 4 y)])
&lt;&#x2F;span&gt;&lt;span&gt;    (list (vrule x 0 y #:style &amp;#39;long-dash)
&lt;&#x2F;span&gt;&lt;span&gt;          (hrule y 0 x #:style &amp;#39;long-dash)
&lt;&#x2F;span&gt;&lt;span&gt;          (point-label (vector x y) (format &amp;quot;x = ~a    y = ~a&amp;quot; x* y*)))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(define (plot-probability-of-collison bucket-size label [halfway-probability #f])
&lt;&#x2F;span&gt;&lt;span&gt;  (let ([g (if halfway-probability halfway-probability (sqrt bucket-size))]
&lt;&#x2F;span&gt;&lt;span&gt;        [bucket-size-root (sqrt bucket-size)]
&lt;&#x2F;span&gt;&lt;span&gt;        [fn               ((curry probability-of-collision) bucket-size)])
&lt;&#x2F;span&gt;&lt;span&gt;    (parameterize ([plot-x-transform  log-transform]
&lt;&#x2F;span&gt;&lt;span&gt;                   [plot-width 750])
&lt;&#x2F;span&gt;&lt;span&gt;      (plot
&lt;&#x2F;span&gt;&lt;span&gt;       (list
&lt;&#x2F;span&gt;&lt;span&gt;        (function fn 1  bucket-size #:label label)
&lt;&#x2F;span&gt;&lt;span&gt;        (label-point-at g (fn g)))
&lt;&#x2F;span&gt;&lt;span&gt;       #:x-label &amp;quot;Sample size&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;       #:y-label &amp;quot;Probability of collision&amp;quot;))))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(plot-probability-of-collison 365 &amp;quot;Birthday&amp;quot; 23)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(plot-probability-of-collison (expt 2 256) &amp;quot;SHA 256&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-birthday-attack&quot;&gt;The Birthday Attack&lt;&#x2F;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Birthday_attack&quot;&gt;birthday attack&lt;&#x2F;a&gt;, an attacker when given a hash, guesses a string that
will generate the same hash. If there no collisions the attacker would have to
come up with the exact string that generated the hash. If there are collisions
the attacker could get away with guessing a different string.&lt;&#x2F;p&gt;
&lt;p&gt;This is out of the scope of this post but &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Birthday_attack&quot;&gt;birthday attack&lt;&#x2F;a&gt; and
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Birthday_problem&quot;&gt;birthday problem&lt;&#x2F;a&gt; wikipedia pages can provide further reading.
There&#x27;s also this lecture on YouTube from the Coursera cryptography course
&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=5VY2KEh9WrE&quot;&gt;Cryptography generic birthday attack (collision resistance)&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;applied-to-variation&quot;&gt;Applied to Variation&lt;&#x2F;h1&gt;
&lt;p&gt;For a 256 bit hash we have 2&lt;sup&gt;256&lt;&#x2F;sup&gt; as our bucket size.
We then have the square root of that being
2&lt;sup&gt;(256&#x2F;2)&lt;&#x2F;sup&gt; = 2&lt;sup&gt;128&lt;&#x2F;sup&gt; approximately 3.4*10&lt;sup&gt;38&lt;&#x2F;sup&gt; as
the sample size below which we have 0.5 chance of collision.&lt;&#x2F;p&gt;
&lt;p&gt;For context, the human genome is approximately 3*10&lt;sup&gt;6&lt;&#x2F;sup&gt; (billion)
nucleotides long, which is much smaller than  3.4*10&lt;sup&gt;38&lt;&#x2F;sup&gt;.
Viruses have even shorter genomes, ranging in kilo (thousand) nucleotides,
for example, the RSV genome is approximately 15*10&lt;sup&gt;3&lt;&#x2F;sup&gt; nucleotides long
which is even shorter than 3.4*10&lt;sup&gt;38&lt;&#x2F;sup&gt; when compared to the human genome.&lt;&#x2F;p&gt;
&lt;p&gt;The number of variations we expect in these genomes is therefore much smaller
than 2&lt;sup&gt;128&lt;&#x2F;sup&gt;. As a side note, SHA256 is
&lt;a href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;bBC-nXj3Ng4?t=343&quot;&gt;used to uniquely identify bitcoin&lt;&#x2F;a&gt; which there are a lot of.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;how-much-variation-can-actually-occur&quot;&gt;How Much Variation Can Actually Occur?&lt;&#x2F;h1&gt;
&lt;p&gt;The short answer is: we don&#x27;t know for sure but we can estimate its upper bound.&lt;&#x2F;p&gt;
&lt;p&gt;Given we look at genomes that are in the same species or quasi species we expect
99% similarity.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1% of the human genome would be approximately 3*10&lt;sup&gt;4&lt;&#x2F;sup&gt; (thirty thousand)
nucleotides long.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;1% of RSV would be approximately 15*10&lt;sup&gt;3&lt;&#x2F;sup&gt; (a hundred and fifty)
nucleotides long.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is the space within which we expect the variation to occur.&lt;&#x2F;p&gt;
&lt;p&gt;Granted, we still don&#x27;t know just how much variation could occur, which in
reality would depend on the organism, we have reduced the problem space by
orders of magnitude below 2&lt;sup&gt;128&lt;&#x2F;sup&gt; making SHA256 look really good.&lt;&#x2F;p&gt;
&lt;p&gt;I expect the biggest problem with SHA256 to come from the space cost of
hashing in terms of both disk and&#x2F;or memory.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Creating the Initial Variation Graph</title>
		<published>2019-07-15T00:00:00+00:00</published>
		<updated>2019-07-15T00:00:00+00:00</updated>
		<link href="https://njagi.me/posts/creating-the-initial-variation-graph/" type="text/html"/>
		<id>https://njagi.me/posts/creating-the-initial-variation-graph/</id>
		<content type="html">&lt;p&gt;Variation graphs represent the reference genome as a graph.
For an introduction, read my previous post &lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;creating-the-initial-variation-graph&#x2F;2019-06-22-Introduction-to-Variation-Graphs.html&quot;&gt;An Introduction to Variation Graphs&lt;&#x2F;a&gt;
or &lt;a href=&quot;https:&#x2F;&#x2F;ekg.github.io&#x2F;2019&#x2F;07&#x2F;09&#x2F;Untangling-graphical-pangenomics&quot;&gt;Untangling graphical pangenomics&lt;&#x2F;a&gt; by Erik Garrison.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Core to variation graphs is the maintenance of a tight mapping
between the reference and the graph.
To maintain this mapping we establish a &lt;em&gt;coordinate system&lt;&#x2F;em&gt; — a way to reliably
associate a node in the graph, with a position in the reference and vice versa.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;coordinate_system.png&quot; alt=&quot;coordinate systems&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-coordinate-system&quot;&gt;A Coordinate System&lt;&#x2F;h1&gt;
&lt;p&gt;We use the concepts &lt;strong&gt;offset&lt;&#x2F;strong&gt; and &lt;strong&gt;ref&lt;&#x2F;strong&gt; to maintain a coordinate system.&lt;&#x2F;p&gt;
&lt;p&gt;An &lt;strong&gt;offset&lt;&#x2F;strong&gt; is the number of bases from the first node where the
variation occurs; offsets are one-indexed in the reference but zero-indexed in
the graph. Offsets are suited to translating linear reference to graphs because
it&#x27;s how variations are viewed within the reference anyway.&lt;&#x2F;p&gt;
&lt;p&gt;For example, we could represent a variation &amp;quot;A&amp;quot; occuring at position 3 in the 
reference &amp;quot;ATCGAT&amp;quot; as:
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;offsets.svg&quot; alt=&quot;offsets&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Notice how we start counting from 0 in the graph? We call that being zero-indexed.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;strong&gt;ref&lt;&#x2F;strong&gt; is a unique identifier which we get from the reference
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FASTA_format#Description_line&quot;&gt;description line&lt;&#x2F;a&gt;. A graph created from just one reference will have all nodes
contain the same value in the &lt;code&gt;ref&lt;&#x2F;code&gt; field.&lt;&#x2F;p&gt;
&lt;p&gt;As you may have suspected, some problems arise from this coordinate system.
They are a matter of &lt;em&gt;progressive update&lt;&#x2F;em&gt; and &lt;em&gt;read alignment&lt;&#x2F;em&gt; but not a matter
of initial graph construction and are therefore beyond the scope of this post.
They include:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dealing with nodes that are from alignments i.e. not aligned to a linear
sequence&lt;&#x2F;li&gt;
&lt;li&gt;Changes in the linear reference which change the coordinate system.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h1 id=&quot;structure-of-the-graph&quot;&gt;Structure of the Graph&lt;&#x2F;h1&gt;
&lt;p&gt;Properties of our graph:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Directed acyclic graph&lt;&#x2F;li&gt;
&lt;li&gt;Offsets are &lt;strong&gt;increasing&#x2F;ascending&lt;&#x2F;strong&gt; natural numbers as we walk through the
graph&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;node&quot;&gt;Node&lt;&#x2F;h2&gt;
&lt;p&gt;A node is built out of a racket &lt;code&gt;structure&lt;&#x2F;code&gt;, a &lt;code&gt;struct&lt;&#x2F;code&gt; in many
languages, with the following fields:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Name&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;segment&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;a string of alphabet A, T, C, and G&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;offset&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;offset from zero on the reference&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;id&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;sha256 hash of the concatenation of segment, &amp;quot;+&amp;quot; and offset&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;ref&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;reference from which the segment is derived&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;links&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;a list of the IDs of the next nodes&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The use of &lt;code&gt;segment&lt;&#x2F;code&gt; and &lt;code&gt;links&lt;&#x2F;code&gt; to mean &lt;code&gt;vertices&lt;&#x2F;code&gt; and &lt;code&gt;edges&lt;&#x2F;code&gt; are inspired by
&lt;a href=&quot;https:&#x2F;&#x2F;lh3.github.io&#x2F;2014&#x2F;07&#x2F;19&#x2F;a-proposal-of-the-grapical-fragment-assembly-format&quot;&gt;A proposal of the Graphical Fragment Assembly format&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We generate a sha256 hash out of the segment, a plus symbol and the offset to
generate a value for &lt;code&gt;id&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For example, given a segment &lt;em&gt;&amp;quot;ATCGATG&amp;quot;&lt;&#x2F;em&gt; at offset &lt;em&gt;34&lt;&#x2F;em&gt; we can generate an ID
like so:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;generate-id(&amp;lt;string&amp;gt; segment, &amp;lt;natural-number&amp;gt; offset)
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; take note of the + sign in the concatenation
&lt;&#x2F;span&gt;&lt;span&gt;  string-and-offset  &amp;lt;- concatenate(&amp;quot;ATCGATG&amp;quot;, &amp;quot;+&amp;quot;,&amp;quot;34&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;  hash-as-bytestring &amp;lt;- sha256hash(string-and-offset)
&lt;&#x2F;span&gt;&lt;span&gt;  id                 &amp;lt;- bytestring-to-hex-string(hash-as-bytestring)
&lt;&#x2F;span&gt;&lt;span&gt;  return id
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I chose hashes over UUIDs because they are reproducible and will
have constant time lookups in the occasion that we want to retrieve a node from
the graph given its sequence and offset. This should come in handy in
visualization especially on the web.&lt;&#x2F;p&gt;
&lt;p&gt;I also considered the likelihood of collisions in the hashes. I  expect it to be
low when dealing with 15,000 base pair size viruses.
I shall expound on this in a later post.
One thing to note is that &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&quot;&gt;vg&lt;&#x2F;a&gt; uses UUIDs and they work for
human genome so I believe &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;graphite&lt;&#x2F;a&gt;, the tool that I&#x27;m writing to implement
this, can get away with sha256 hashes for more complex genomes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variation&quot;&gt;Variation&lt;&#x2F;h2&gt;
&lt;p&gt;A variation is a &lt;code&gt;structure&lt;&#x2F;code&gt; containing the following fields:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Name&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;segment&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;a string of single of alphabet A, T, C, and G&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;offset&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;offset from zero on the reference&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;ref&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;an identifier of the reference it&#x27;s derived from&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;It is extracted from a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Variant_Call_Format&quot;&gt;Variant Call Format&lt;&#x2F;a&gt; file, the main file format for genomic
variation data.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-graph&quot;&gt;The Graph&lt;&#x2F;h2&gt;
&lt;p&gt;I had to implement a graph in graphite due to the lack of serialization (a
required feature for progressive updates) in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stchang&#x2F;graph&quot;&gt;racket graph library&lt;&#x2F;a&gt;;
I would have preferred to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stchang&#x2F;graph&#x2F;issues&#x2F;47&quot;&gt;add serialization support to graph&lt;&#x2F;a&gt; but couldn&#x27;t
do that and still stay on track with graphite.&lt;&#x2F;p&gt;
&lt;p&gt;The graph is built out of an adjacency map of &lt;code&gt;id&lt;&#x2F;code&gt;, key, to &lt;code&gt;node&lt;&#x2F;code&gt;, value.&lt;&#x2F;p&gt;
&lt;p&gt;Using a &lt;code&gt;hash table&lt;&#x2F;code&gt; and not a &lt;code&gt;list&lt;&#x2F;code&gt; has the following pros:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;no duplicates&lt;&#x2F;li&gt;
&lt;li&gt;constant-time lookups if we have a &lt;code&gt;segment&lt;&#x2F;code&gt; and its &lt;code&gt;offset&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;and cons:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;lacks ordering despite linear offsets which would come in handy for updates&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;construction&quot;&gt;Construction&lt;&#x2F;h1&gt;
&lt;p&gt;The general idea is:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Given a &lt;code&gt;list&lt;&#x2F;code&gt; of variation &lt;code&gt;structures&lt;&#x2F;code&gt; &lt;strong&gt;sorted&lt;&#x2F;strong&gt; by &lt;code&gt;offset&lt;&#x2F;code&gt; and a
linear reference (&lt;code&gt;string&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;Loop through each variation and insert an alternative segment into the
reference at the position specified in the variation.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In the case of graphite, we recursively split the reference into a &lt;em&gt;list&lt;&#x2F;em&gt; of
&lt;em&gt;pairs&lt;&#x2F;em&gt; that imply directionality.
For example, the pair &lt;code&gt;(a b)&lt;&#x2F;code&gt; would translate to an edge from &lt;em&gt;node a&lt;&#x2F;em&gt; to &lt;em&gt;node b&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We then have a function &lt;code&gt;gen-directed-graph&lt;&#x2F;code&gt; that takes this &lt;code&gt;list&lt;&#x2F;code&gt; of &lt;code&gt;pairs&lt;&#x2F;code&gt;
and generates a directed graph from it using &lt;code&gt;foldl&lt;&#x2F;code&gt;. Graphite creates the graph
in the 3 steps detailed below.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;1-generate-a-node-list-of-pairs&quot;&gt;1. Generate a Node List (of Pairs)&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;O(n)&lt;&#x2F;em&gt;; n being the size of the variation list&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;gen-node-list(reference, variations, prev-position = f, prev-nodes = &amp;lt;empty-list&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  if empty-list? variations
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; the base case of gen node list
&lt;&#x2F;span&gt;&lt;span&gt;    cap(reference, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  else if (is-number previous-position) and (previous-position = current-offset)
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; we have more than one variation in this position
&lt;&#x2F;span&gt;&lt;span&gt;    handle-duplicate(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  else
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; we have just one variation in this position
&lt;&#x2F;span&gt;&lt;span&gt;    handle-unique(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;reference&lt;&#x2F;strong&gt;: the linear reference&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;variations&lt;&#x2F;strong&gt;: a list of variations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;prev-position&lt;&#x2F;strong&gt;: the offset of the previous variation
&lt;ul&gt;
&lt;li&gt;the default value is false. (I wish I used an int here)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;prev-nodes&lt;&#x2F;strong&gt;: the previous node or nodes with relation to the current one
&lt;ul&gt;
&lt;li&gt;the default value is an empty list.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;A mutually recursive function takes from the &lt;code&gt;tail&lt;&#x2F;code&gt; of variation list,
&lt;code&gt;variations&lt;&#x2F;code&gt;, and returns a list of pair of nodes &lt;code&gt;(a, b)&lt;&#x2F;code&gt; where the direction
of the nodes is &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; for example a list like &lt;code&gt;[(a b), (b c), (c d)]&lt;&#x2F;code&gt; should
later  translate to &lt;code&gt;a -&amp;gt; b -&amp;gt; c -&amp;gt; d&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-1-cap&quot;&gt;1.1 Cap&lt;&#x2F;h3&gt;
&lt;p&gt;Creates the initial variation i.e &amp;quot;caps&amp;quot; the directed graph.
It creates a first node that points to the first variations.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;cap(reference, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  map(
&lt;&#x2F;span&gt;&lt;span&gt;    lambda node: (substring(reference, 0, previous-position), node)
&lt;&#x2F;span&gt;&lt;span&gt;    previous-nodes
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;1-2-handle-unique&quot;&gt;1.2 Handle Unique&lt;&#x2F;h3&gt;
&lt;p&gt;Inserts a variation where there isn&#x27;t an alternative.
In a case where there&#x27;s only 1 alternative path so we break the current sequence
and insert our alternative path, for example,  &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; and &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;handle-unique(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;1-3-handle-duplicate&quot;&gt;1.3 Handle Duplicate&lt;&#x2F;h3&gt;
&lt;p&gt;Inserts extra alternative variations where they already exist.
for example &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt;, &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt; and &lt;code&gt;a -&amp;gt; d&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;handle-duplicate(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;2-generate-a-directed-graph-out-of-a-list-of-pairs&quot;&gt;2. Generate a Directed Graph Out of a List of Pairs&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;O(n)&lt;&#x2F;em&gt;; with n being the size of the list of pairs&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;gen-directed-graph(g, list-of-pairs)
&lt;&#x2F;span&gt;&lt;span&gt;  foldl(
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; make sure that you&amp;#39;re not overwriting the list of edges of a node as you
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; update it. This check makes `gen-directed-graph` slow approx 4n.
&lt;&#x2F;span&gt;&lt;span&gt;  lambda pair: add-adjacent-node(g, first(pair), second(pair))
&lt;&#x2F;span&gt;&lt;span&gt;  g
&lt;&#x2F;span&gt;&lt;span&gt;  list-of-pairs)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;g&lt;&#x2F;strong&gt;: a graph&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;list-of-pairs&lt;&#x2F;strong&gt;: a list of pairs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The reason for the bad performance of &lt;code&gt;gen-directed-graph&lt;&#x2F;code&gt; is that it checks to
avoid overwriting any existing nodes.
This is to mean that if there&#x27;s a relationship like:
&lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; and &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt;
we have to make sure not to lose the edge &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; when creating &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt;.
It, however, does suffice for virus data.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;3-return-a-variation-graph&quot;&gt;3. Return a Variation Graph&lt;&#x2F;h2&gt;
&lt;p&gt;A composition of &lt;code&gt;gen-node-list&lt;&#x2F;code&gt; and &lt;code&gt;gen-directed-graph&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;gen-vg(reference, variations)
&lt;&#x2F;span&gt;&lt;span&gt;  node-list &amp;lt;- gen-node-list(reference, variation)
&lt;&#x2F;span&gt;&lt;span&gt;  graph     &amp;lt;- gen-directed-graph(node-list)
&lt;&#x2F;span&gt;&lt;span&gt;  return graph
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;visualization-and-output&quot;&gt;Visualization and Output&lt;&#x2F;h1&gt;
&lt;p&gt;Graphite supports the generation of graphs in:
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;GFA-spec&#x2F;GFA-spec&quot;&gt;GFA&lt;&#x2F;a&gt;, for interoperability with tools such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&quot;&gt;vg&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;rrwick.github.io&#x2F;Bandage&#x2F;&quot;&gt;bandage&lt;&#x2F;a&gt;;
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DOT_(graph_description_language)&quot;&gt;DOT&lt;&#x2F;a&gt;, for visualization; and a serialized form, .gra.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;optimization-idea&quot;&gt;Optimization Idea&lt;&#x2F;h1&gt;
&lt;p&gt;Representing the alphabet in 4 bits, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;biod&#x2F;BioD&#x2F;blob&#x2F;57c81f275faab5cdec4746bfc7af81e31bac0f69&#x2F;bio&#x2F;core&#x2F;base.d#L64&quot;&gt;as is done in BioD&lt;&#x2F;a&gt;, because:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the extra bits accommodate ambiguous bases&lt;&#x2F;li&gt;
&lt;li&gt;we could then perform fast and efficient complimenting though bit shifting&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The alphabet would be:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A as 0001&lt;&#x2F;li&gt;
&lt;li&gt;C as 0010&lt;&#x2F;li&gt;
&lt;li&gt;T as 0100&lt;&#x2F;li&gt;
&lt;li&gt;G as 1000&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;However, most of the optimization would come from graph creation, graph
update and search which is what I&#x27;m focused on for now.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>An Introduction to Variation Graphs</title>
		<published>2019-06-22T00:00:00+00:00</published>
		<updated>2019-06-22T00:00:00+00:00</updated>
		<link href="https://njagi.me/posts/introduction-to-variation-graphs/" type="text/html"/>
		<id>https://njagi.me/posts/introduction-to-variation-graphs/</id>
		<content type="html">&lt;p&gt;I expect the audience of this post to be both programmers and biologists so I&#x27;ll
bring you up to speed on a topic before going into it.
Feel free to skip a sentence, paragraph or even section if you&#x27;re familiar with a topic.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;genome-sequencing&quot;&gt;Genome sequencing&lt;&#x2F;h2&gt;
&lt;p&gt;A &lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Genome&quot;&gt;genome&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; is the entire genetic code of an organism. While computational data
is  represented in binary form, ones, and zeros, biochemical data is represented
by nitrogenous &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Base_(chemistry)&quot;&gt;bases&lt;&#x2F;a&gt; that seem to stick out of a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DNA&quot;&gt;DNA&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RNA&quot;&gt;RNA&lt;&#x2F;a&gt; molecule&#x2F;strand
abbreviated A, T, C, and G for DNA and A, G, C and U for RNA.
We care about RNA because some viruses have RNA and not
DNA.&lt;&#x2F;p&gt;
&lt;p&gt;If this is confusing, you can think of a strand of DNA or RNA as a thread  with
knots where each knot is a base.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;strong&gt;sequence&lt;&#x2F;strong&gt; is an &lt;em&gt;ordering&lt;&#x2F;em&gt; of something.
A programming analog is a sequence vs a collection. Sequences are ordered,
for example lists, and therefore have the potential for a &lt;em&gt;next&lt;&#x2F;em&gt; and a &lt;em&gt;previous&lt;&#x2F;em&gt;
element while collections are just data thrown together, for example, a
dictionary or a set.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Genome sequencing&lt;&#x2F;strong&gt; (or sequencing a genome) therefore, is determining the
order of bases in all of the DNA or RNA in an organism. What makes this easy is
that all the cells in an individual organism have the same DNA so we can
get all the DNA in an organism from a single cell.
In practice, however, we can&#x27;t work with a single cell due to its size.
Ignore chromosomes, haplotypes and other things you may know about DNA for now.&lt;&#x2F;p&gt;
&lt;p&gt;To determine the sequence of bases in an entire genome of an organism we focus
on only one of the alleles (a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Haplotype&quot;&gt;haplotype&lt;&#x2F;a&gt;) and only one strand of the
double helix.
Since 2005 we&#x27;ve used methods broadly categorized
under &lt;strong&gt;Next Generation Sequencing (NGS)&lt;&#x2F;strong&gt; to perform genome sequencing.
There are two main ways of performing NGS:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Shear the DNA into small fragments, sequence those and try to build back the
original sequence. An analogy that’s used is shredding a newspaper article
then trying to recreate it.&lt;&#x2F;li&gt;
&lt;li&gt;Run the DNA strand like a train would run through a tunnel through a pore
and read the sequence of bases.
There are other methods of reading entire strands of DNA but they don&#x27;t matter
in this context.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;As you would expect, each method has its drawbacks and advantages.
What we get out of the machine that does the actual sequencing of DNA is called
a read and reads have to be &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequence_alignment&quot;&gt;aligned&lt;&#x2F;a&gt; and
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequence_assembly&quot;&gt;assembled&lt;&#x2F;a&gt;&lt;sup&gt;2&lt;&#x2F;sup&gt;.
Alignment involves stacking reads on top of each other and assembling is the
greater process that involves alignment, algorithmically choosing the best
alignment and determining what the original sequence was.&lt;&#x2F;p&gt;
&lt;p&gt;There are two broad categories of assembly&lt;sup&gt;4&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;De-novo assembly:&lt;&#x2F;strong&gt; this is where we sequence a genome that has never been
sequenced before&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Mapping assembly:&lt;&#x2F;strong&gt; this is sequencing an organism’s unique code despite
having the general sequence for the species. What you get from services
like &lt;a href=&quot;https:&#x2F;&#x2F;www.23andme.com&#x2F;en-int&#x2F;&quot;&gt;23andMe&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;the-reference-genome&quot;&gt;The reference genome&lt;&#x2F;h2&gt;
&lt;p&gt;A &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Reference_genome&quot;&gt;reference genome&lt;&#x2F;a&gt; is a consensus sequence that accepted as the genome of a
species&lt;sup&gt;2&lt;&#x2F;sup&gt;. It’s stored as one long sequence of characters&#x2F;bases.
You may wonder how we can have a known genome of an entire species when every
individual has a unique genetic code or how &lt;a href=&quot;https:&#x2F;&#x2F;www.scientificamerican.com&#x2F;article&#x2F;tiny-genetic-differences-between-humans-and-other-primates-pervade-the-genome&#x2F;&quot;&gt;humans are 99% chimp&lt;&#x2F;a&gt;.
Well, the answer is that genetic code of most organisms
is similar and this similarity increases as we narrow down taxonomically.
When we say that &lt;a href=&quot;https:&#x2F;&#x2F;www.scientificamerican.com&#x2F;article&#x2F;tiny-genetic-differences-between-humans-and-other-primates-pervade-the-genome&#x2F;&quot;&gt;a human is closer to a chimp than a monkey&lt;&#x2F;a&gt; what we mean is
that we can observe greater variation between the genomes of the two, man+chimp vs monkey, than man vs chimp alone.&lt;&#x2F;p&gt;
&lt;p&gt;This isn&#x27;t actual math but may help clear things up.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;variation(combine_genomes(man, chimp), monkey) &amp;gt; variation(man, chimp)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;variation-in-genomes&quot;&gt;Variation in genomes&lt;&#x2F;h1&gt;
&lt;p&gt;However, there are still genomic differences and they should not be ignored.
&lt;em&gt;The ignoring of differences is implicit in a linear reference.&lt;&#x2F;em&gt;
A better way to describe them is to say that the differences are segregating within the population.
We may also want to carry out a comparison between species or between related
species which is done in &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pan-genome&quot;&gt;pangenomics&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;DNA has sections which are identical between individuals (conserved regions), and
the number of these  sections grow as we narrow down taxonomically and there are
sections which vary between individuals, for example, the short sequence repeats
that are compared in paternity testing.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graph_theory&quot;&gt;Graph theory&lt;&#x2F;a&gt; is an area in math that can help us understand variable
regions within genomes. The idea of representing genomes as graphs isn’t new,
however, the low number of tools like &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&quot;&gt;vg&lt;&#x2F;a&gt; which apply graph theory to genomics
and the little that we know about genomes has been a drawback.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;graphs&quot;&gt;Graphs&lt;&#x2F;h1&gt;
&lt;p&gt;A &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graph_theory&quot;&gt;graph&lt;&#x2F;a&gt; is a series of vertices (also known as nodes) and edges.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;all_graphs.png&quot; alt=&quot;all graphs&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For genome graphs, we focus on directed acyclic graphs.
A &lt;strong&gt;walk&lt;&#x2F;strong&gt; in a directed graph is traversal from one node to another through an
edge, for example, &lt;em&gt;a&lt;&#x2F;em&gt; to &lt;em&gt;b&lt;&#x2F;em&gt; to &lt;em&gt;d&lt;&#x2F;em&gt; or &lt;em&gt;a&lt;&#x2F;em&gt; to &lt;em&gt;c&lt;&#x2F;em&gt; to &lt;em&gt;d&lt;&#x2F;em&gt;.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;directed_graph.png&quot; alt=&quot;directed graph&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-current-state-of-affairs&quot;&gt;The current state of affairs&lt;&#x2F;h1&gt;
&lt;p&gt;Once the reference genome of an organism has been determined, it is stored in
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FASTA_format&quot;&gt;fasta format&lt;&#x2F;a&gt; which contains the sequence and metadata. Moving forward, anyone
sequencing the same species aligns against this reference. Differences that occur
in less than 1% of the reads are usually thrown out;
the ones that aren’t thrown out don’t help to update the reference but are stored
in &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Variant_Call_Format&quot;&gt;Variant Call Format (VCF)&lt;&#x2F;a&gt; which contains the variation data and their
positions plus metadata. These VCF files are spread out amongst researchers and
aid in the particular thing being researched but generally don’t contribute in
and of themselves to the general genomic body of knowledge.
However, every once in awhile the reference is updated but not on a fixed
schedule&lt;sup&gt;2&lt;&#x2F;sup&gt;.
It’s for this reason that the variation graph would be a good way of
representing the reference. There is research that confirmed that short
reads align better to the variation graph than to a linear reference&lt;sup&gt;3&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;graphs-and-genomes&quot;&gt;Graphs and genomes&lt;&#x2F;h1&gt;
&lt;p&gt;Graphs that are applied to genomes are generally called &lt;strong&gt;genome graphs&lt;&#x2F;strong&gt;.
However, there are two more specific categories which are sequence graphs and
variation graphs.&lt;&#x2F;p&gt;
&lt;p&gt;As an example assume that we zoom on a hypothetical reference: &lt;strong&gt;&amp;quot;ACTGAATTTGTA&amp;quot;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Variation&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Position&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Alternative&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Variation1&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;2&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;GGGA&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Variation2&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;4&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;C&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;We could recursively insert Variation1 at position 2 and Variation2 at position
4 to generate the graph below:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;example.png&quot; alt=&quot;sequence graph&quot; &#x2F;&gt;
(generated using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;graphite&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graph&quot;&gt;my current fork of graph&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;In this case, a single walk would represent a possible genome. Compared to the
reference, this variation information is maintained and the graph still holds
the data that was in reference.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sequence-graphs&quot;&gt;Sequence Graphs&lt;&#x2F;h2&gt;
&lt;p&gt;These are graphs with sequence labels on the nodes or edges.&lt;&#x2F;p&gt;
&lt;p&gt;Sequence graphs or equivalent structures have been used previously to represent
multiple sequences that contain shared differences or ambiguities in a single
structure. Related structures used in genome assembly which collapse long
repeated sequences, so the same nodes are used for different regions of the
genome include the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;De_Bruijn_graph&quot;&gt;De Bruijn graph&lt;&#x2F;a&gt;&lt;sup&gt;5&lt;&#x2F;sup&gt;. Graphs to represent genetic variation
have previously been used for microbial genomes &amp;amp; localized regions of the human
genome such as the major &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Histocompatibility&quot;&gt;histocompatibility&lt;&#x2F;a&gt; complex.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variation-graphs&quot;&gt;Variation Graphs&lt;&#x2F;h2&gt;
&lt;p&gt;A variation graph is a sequence graph together with a set of paths representing
possible sequences from a population. However, what makes it so unique is it&#x27;s
tight mapping between the graph and the reference.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variation-graphs-and-rsv&quot;&gt;Variation graphs and RSV&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Human_orthopneumovirus&quot;&gt;Human orthopneumovirus&lt;&#x2F;a&gt;, formerly known as Respiratory Syncytial Virus (RSV),
is a single-stranded RNA virus and a good candidate for exploration using the
variation graph because viruses don’t have proofreading in their genetic code.
Proofreading is a process in which the cell ensures that it has copied the
genetic code correctly in preparation for cell division. Without proofreading,
errors will be commonplace leading to high mutation rates.
Another advantage is the size of its genome; the reference stands at
15,206 bases which translate to 15206 bytes or 14.8 KB of memory.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;generating-a-variation-graph&quot;&gt;Generating a variation graph&lt;&#x2F;h1&gt;
&lt;p&gt;As of writing this, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;graphite&lt;&#x2F;a&gt; can’t generate a graph out of reads alone
(perform an alignment). It supports a reference in fasta and a single VCF file.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll detail the algorithm in a &lt;a href=&quot;&#x2F;posts&#x2F;2019-07-15-Creating-the-Initial-Variation-Graph.html&quot;&gt;later post&lt;&#x2F;a&gt; but the gist of it is this:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Load the reference into memory or read a chunk of it if you wish&lt;&#x2F;li&gt;
&lt;li&gt;Load your variation data from a VCF&lt;&#x2F;li&gt;
&lt;li&gt;Organize variations into structs containing
&lt;ul&gt;
&lt;li&gt;variation&lt;&#x2F;li&gt;
&lt;li&gt;position&lt;&#x2F;li&gt;
&lt;li&gt;reference&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Sort the variations in ascending order by position&lt;&#x2F;li&gt;
&lt;li&gt;Using a right fold function - for support of streams
&lt;ol&gt;
&lt;li&gt;fold through the list of variations&lt;&#x2F;li&gt;
&lt;li&gt;At each variation position split the reference and create a list of:
&lt;ul&gt;
&lt;li&gt;the string to the left&lt;&#x2F;li&gt;
&lt;li&gt;string to the right&lt;&#x2F;li&gt;
&lt;li&gt;a list of the variation and the base that was there originally (this will be a list of lists)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Create directed graph out of the list of lists generated by the fold
* &lt;code&gt;&#x27;((a b) (a c)) to become a node with edges from a to b and c to be and a-&amp;gt;b and a-&amp;gt;b&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;variation&quot;&gt;Variation&lt;&#x2F;h2&gt;
&lt;p&gt;A variation is a struct of &lt;code&gt;position&lt;&#x2F;code&gt; and &lt;code&gt;sequence&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I’m using the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stchang&#x2F;graph&quot;&gt;racket graph library graph&lt;&#x2F;a&gt; to generate a graph out of the nested
lists and treating the graph as a “dynamic tree”.&lt;&#x2F;p&gt;
&lt;p&gt;We then rely on graph to generate an unweighted directed graph through
&lt;a href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;graph&#x2F;index.html#%28def._%28%28lib._graph%2Fmain..rkt%29._unweighted-graph%2Fdirected%29%29&quot;&gt;unweighted-graph&#x2F;directed&lt;&#x2F;a&gt;.
We export the graph in dot format and visualize via &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graphviz&quot;&gt;graphviz&lt;&#x2F;a&gt;. Serialization isn’t implemented yet.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;references&quot;&gt;References&lt;&#x2F;h1&gt;
&lt;ol&gt;
&lt;li&gt;Adam M. Novak, Erik Garrison, Benedict Paten A graph extension of the positional burrows-wheeler transform and its applications bioRxiv 051409; doi: https:&#x2F;&#x2F;doi.org&#x2F;10.1101&#x2F;051409&lt;&#x2F;li&gt;
&lt;li&gt;Church DM, Schneider VA, Graves T, Auger K, Cunningham F, Bouk N, et al. (2011) Modernizing Reference Genome Assemblies. PLoS Biol 9(7): e1001091. https:&#x2F;&#x2F;doi.org&#x2F;10.1371&#x2F;journal.pbio.1001091&lt;&#x2F;li&gt;
&lt;li&gt;Garrison, Erik &amp;amp; Sirén, Jouni &amp;amp; M Novak, Adam &amp;amp; Hickey et al. (2018). Variation graph toolkit improves read mapping by representing genetic variation in the reference. Nature Biotechnology. 36. 10.1038&#x2F;nbt.4227&lt;&#x2F;li&gt;
&lt;li&gt;Wolf, Beat. &amp;quot;De novo genome assembly versus mapping to a reference genome&amp;quot; (PDF). University of Applied Sciences Western Switzerland. Retrieved 6 April 2019.&lt;&#x2F;li&gt;
&lt;li&gt;Holley, Guillaume &amp;amp; Peterlongo, Pierre. (2012). BLASTGRAPH: Intensive approximate pattern matching in sequence graphs and de-Bruijn graphs. Proceedings of the Prague Stringology Conference, PSC 2012.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
</feed>
