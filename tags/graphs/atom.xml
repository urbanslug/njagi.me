<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Mostly Programming - Graphs</title>
	<subtitle>Programming, Bioinformatics, Data, Books, and More</subtitle>
	<link href="https://njagi.me/tags/graphs/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://njagi.me"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2019-07-15T00:00:00+00:00</updated>
	<id>https://njagi.me/tags/graphs/atom.xml</id>
	<entry xml:lang="en">
		<title>Creating the Initial Variation Graph</title>
		<published>2019-07-15T00:00:00+00:00</published>
		<updated>2019-07-15T00:00:00+00:00</updated>
		<link href="https://njagi.me/posts/creating-the-initial-variation-graph/" type="text/html"/>
		<id>https://njagi.me/posts/creating-the-initial-variation-graph/</id>
		<content type="html">&lt;p&gt;Variation graphs represent the reference genome as a graph.
For an introduction, read my previous post &lt;a href=&quot;https:&#x2F;&#x2F;njagi.me&#x2F;posts&#x2F;creating-the-initial-variation-graph&#x2F;2019-06-22-Introduction-to-Variation-Graphs.html&quot;&gt;An Introduction to Variation Graphs&lt;&#x2F;a&gt;
or &lt;a href=&quot;https:&#x2F;&#x2F;ekg.github.io&#x2F;2019&#x2F;07&#x2F;09&#x2F;Untangling-graphical-pangenomics&quot;&gt;Untangling graphical pangenomics&lt;&#x2F;a&gt; by Erik Garrison.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;Core to variation graphs is the maintenance of a tight mapping
between the reference and the graph.
To maintain this mapping we establish a &lt;em&gt;coordinate system&lt;&#x2F;em&gt; — a way to reliably
associate a node in the graph, with a position in the reference and vice versa.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;coordinate_system.png&quot; alt=&quot;coordinate systems&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-coordinate-system&quot;&gt;A Coordinate System&lt;&#x2F;h1&gt;
&lt;p&gt;We use the concepts &lt;strong&gt;offset&lt;&#x2F;strong&gt; and &lt;strong&gt;ref&lt;&#x2F;strong&gt; to maintain a coordinate system.&lt;&#x2F;p&gt;
&lt;p&gt;An &lt;strong&gt;offset&lt;&#x2F;strong&gt; is the number of bases from the first node where the
variation occurs; offsets are one-indexed in the reference but zero-indexed in
the graph. Offsets are suited to translating linear reference to graphs because
it&#x27;s how variations are viewed within the reference anyway.&lt;&#x2F;p&gt;
&lt;p&gt;For example, we could represent a variation &amp;quot;A&amp;quot; occuring at position 3 in the 
reference &amp;quot;ATCGAT&amp;quot; as:
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;offsets.svg&quot; alt=&quot;offsets&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Notice how we start counting from 0 in the graph? We call that being zero-indexed.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;strong&gt;ref&lt;&#x2F;strong&gt; is a unique identifier which we get from the reference
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FASTA_format#Description_line&quot;&gt;description line&lt;&#x2F;a&gt;. A graph created from just one reference will have all nodes
contain the same value in the &lt;code&gt;ref&lt;&#x2F;code&gt; field.&lt;&#x2F;p&gt;
&lt;p&gt;As you may have suspected, some problems arise from this coordinate system.
They are a matter of &lt;em&gt;progressive update&lt;&#x2F;em&gt; and &lt;em&gt;read alignment&lt;&#x2F;em&gt; but not a matter
of initial graph construction and are therefore beyond the scope of this post.
They include:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Dealing with nodes that are from alignments i.e. not aligned to a linear
sequence&lt;&#x2F;li&gt;
&lt;li&gt;Changes in the linear reference which change the coordinate system.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h1 id=&quot;structure-of-the-graph&quot;&gt;Structure of the Graph&lt;&#x2F;h1&gt;
&lt;p&gt;Properties of our graph:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Directed acyclic graph&lt;&#x2F;li&gt;
&lt;li&gt;Offsets are &lt;strong&gt;increasing&#x2F;ascending&lt;&#x2F;strong&gt; natural numbers as we walk through the
graph&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;node&quot;&gt;Node&lt;&#x2F;h2&gt;
&lt;p&gt;A node is built out of a racket &lt;code&gt;structure&lt;&#x2F;code&gt;, a &lt;code&gt;struct&lt;&#x2F;code&gt; in many
languages, with the following fields:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Name&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;segment&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;a string of alphabet A, T, C, and G&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;offset&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;offset from zero on the reference&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;id&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;sha256 hash of the concatenation of segment, &amp;quot;+&amp;quot; and offset&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;ref&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;reference from which the segment is derived&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;links&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;a list of the IDs of the next nodes&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;The use of &lt;code&gt;segment&lt;&#x2F;code&gt; and &lt;code&gt;links&lt;&#x2F;code&gt; to mean &lt;code&gt;vertices&lt;&#x2F;code&gt; and &lt;code&gt;edges&lt;&#x2F;code&gt; are inspired by
&lt;a href=&quot;https:&#x2F;&#x2F;lh3.github.io&#x2F;2014&#x2F;07&#x2F;19&#x2F;a-proposal-of-the-grapical-fragment-assembly-format&quot;&gt;A proposal of the Graphical Fragment Assembly format&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We generate a sha256 hash out of the segment, a plus symbol and the offset to
generate a value for &lt;code&gt;id&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;For example, given a segment &lt;em&gt;&amp;quot;ATCGATG&amp;quot;&lt;&#x2F;em&gt; at offset &lt;em&gt;34&lt;&#x2F;em&gt; we can generate an ID
like so:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;generate-id(&amp;lt;string&amp;gt; segment, &amp;lt;natural-number&amp;gt; offset)
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; take note of the + sign in the concatenation
&lt;&#x2F;span&gt;&lt;span&gt;  string-and-offset  &amp;lt;- concatenate(&amp;quot;ATCGATG&amp;quot;, &amp;quot;+&amp;quot;,&amp;quot;34&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;  hash-as-bytestring &amp;lt;- sha256hash(string-and-offset)
&lt;&#x2F;span&gt;&lt;span&gt;  id                 &amp;lt;- bytestring-to-hex-string(hash-as-bytestring)
&lt;&#x2F;span&gt;&lt;span&gt;  return id
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I chose hashes over UUIDs because they are reproducible and will
have constant time lookups in the occasion that we want to retrieve a node from
the graph given its sequence and offset. This should come in handy in
visualization especially on the web.&lt;&#x2F;p&gt;
&lt;p&gt;I also considered the likelihood of collisions in the hashes. I  expect it to be
low when dealing with 15,000 base pair size viruses.
I shall expound on this in a later post.
One thing to note is that &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&quot;&gt;vg&lt;&#x2F;a&gt; uses UUIDs and they work for
human genome so I believe &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;graphite&lt;&#x2F;a&gt;, the tool that I&#x27;m writing to implement
this, can get away with sha256 hashes for more complex genomes.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variation&quot;&gt;Variation&lt;&#x2F;h2&gt;
&lt;p&gt;A variation is a &lt;code&gt;structure&lt;&#x2F;code&gt; containing the following fields:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Name&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;segment&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;a string of single of alphabet A, T, C, and G&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;offset&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;offset from zero on the reference&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;ref&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;an identifier of the reference it&#x27;s derived from&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;It is extracted from a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Variant_Call_Format&quot;&gt;Variant Call Format&lt;&#x2F;a&gt; file, the main file format for genomic
variation data.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-graph&quot;&gt;The Graph&lt;&#x2F;h2&gt;
&lt;p&gt;I had to implement a graph in graphite due to the lack of serialization (a
required feature for progressive updates) in the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stchang&#x2F;graph&quot;&gt;racket graph library&lt;&#x2F;a&gt;;
I would have preferred to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stchang&#x2F;graph&#x2F;issues&#x2F;47&quot;&gt;add serialization support to graph&lt;&#x2F;a&gt; but couldn&#x27;t
do that and still stay on track with graphite.&lt;&#x2F;p&gt;
&lt;p&gt;The graph is built out of an adjacency map of &lt;code&gt;id&lt;&#x2F;code&gt;, key, to &lt;code&gt;node&lt;&#x2F;code&gt;, value.&lt;&#x2F;p&gt;
&lt;p&gt;Using a &lt;code&gt;hash table&lt;&#x2F;code&gt; and not a &lt;code&gt;list&lt;&#x2F;code&gt; has the following pros:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;no duplicates&lt;&#x2F;li&gt;
&lt;li&gt;constant-time lookups if we have a &lt;code&gt;segment&lt;&#x2F;code&gt; and its &lt;code&gt;offset&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;and cons:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;lacks ordering despite linear offsets which would come in handy for updates&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;construction&quot;&gt;Construction&lt;&#x2F;h1&gt;
&lt;p&gt;The general idea is:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Given a &lt;code&gt;list&lt;&#x2F;code&gt; of variation &lt;code&gt;structures&lt;&#x2F;code&gt; &lt;strong&gt;sorted&lt;&#x2F;strong&gt; by &lt;code&gt;offset&lt;&#x2F;code&gt; and a
linear reference (&lt;code&gt;string&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;Loop through each variation and insert an alternative segment into the
reference at the position specified in the variation.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In the case of graphite, we recursively split the reference into a &lt;em&gt;list&lt;&#x2F;em&gt; of
&lt;em&gt;pairs&lt;&#x2F;em&gt; that imply directionality.
For example, the pair &lt;code&gt;(a b)&lt;&#x2F;code&gt; would translate to an edge from &lt;em&gt;node a&lt;&#x2F;em&gt; to &lt;em&gt;node b&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We then have a function &lt;code&gt;gen-directed-graph&lt;&#x2F;code&gt; that takes this &lt;code&gt;list&lt;&#x2F;code&gt; of &lt;code&gt;pairs&lt;&#x2F;code&gt;
and generates a directed graph from it using &lt;code&gt;foldl&lt;&#x2F;code&gt;. Graphite creates the graph
in the 3 steps detailed below.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;1-generate-a-node-list-of-pairs&quot;&gt;1. Generate a Node List (of Pairs)&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;O(n)&lt;&#x2F;em&gt;; n being the size of the variation list&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;gen-node-list(reference, variations, prev-position = f, prev-nodes = &amp;lt;empty-list&amp;gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  if empty-list? variations
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; the base case of gen node list
&lt;&#x2F;span&gt;&lt;span&gt;    cap(reference, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  else if (is-number previous-position) and (previous-position = current-offset)
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; we have more than one variation in this position
&lt;&#x2F;span&gt;&lt;span&gt;    handle-duplicate(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  else
&lt;&#x2F;span&gt;&lt;span&gt;    &#x2F;&#x2F; we have just one variation in this position
&lt;&#x2F;span&gt;&lt;span&gt;    handle-unique(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;reference&lt;&#x2F;strong&gt;: the linear reference&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;variations&lt;&#x2F;strong&gt;: a list of variations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;prev-position&lt;&#x2F;strong&gt;: the offset of the previous variation
&lt;ul&gt;
&lt;li&gt;the default value is false. (I wish I used an int here)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;prev-nodes&lt;&#x2F;strong&gt;: the previous node or nodes with relation to the current one
&lt;ul&gt;
&lt;li&gt;the default value is an empty list.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;A mutually recursive function takes from the &lt;code&gt;tail&lt;&#x2F;code&gt; of variation list,
&lt;code&gt;variations&lt;&#x2F;code&gt;, and returns a list of pair of nodes &lt;code&gt;(a, b)&lt;&#x2F;code&gt; where the direction
of the nodes is &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; for example a list like &lt;code&gt;[(a b), (b c), (c d)]&lt;&#x2F;code&gt; should
later  translate to &lt;code&gt;a -&amp;gt; b -&amp;gt; c -&amp;gt; d&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-1-cap&quot;&gt;1.1 Cap&lt;&#x2F;h3&gt;
&lt;p&gt;Creates the initial variation i.e &amp;quot;caps&amp;quot; the directed graph.
It creates a first node that points to the first variations.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;cap(reference, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  map(
&lt;&#x2F;span&gt;&lt;span&gt;    lambda node: (substring(reference, 0, previous-position), node)
&lt;&#x2F;span&gt;&lt;span&gt;    previous-nodes
&lt;&#x2F;span&gt;&lt;span&gt;    )
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;1-2-handle-unique&quot;&gt;1.2 Handle Unique&lt;&#x2F;h3&gt;
&lt;p&gt;Inserts a variation where there isn&#x27;t an alternative.
In a case where there&#x27;s only 1 alternative path so we break the current sequence
and insert our alternative path, for example,  &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; and &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;handle-unique(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;1-3-handle-duplicate&quot;&gt;1.3 Handle Duplicate&lt;&#x2F;h3&gt;
&lt;p&gt;Inserts extra alternative variations where they already exist.
for example &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt;, &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt; and &lt;code&gt;a -&amp;gt; d&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;handle-duplicate(reference, variations, previous-position, previous-nodes)
&lt;&#x2F;span&gt;&lt;span&gt;  ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;2-generate-a-directed-graph-out-of-a-list-of-pairs&quot;&gt;2. Generate a Directed Graph Out of a List of Pairs&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;O(n)&lt;&#x2F;em&gt;; with n being the size of the list of pairs&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;gen-directed-graph(g, list-of-pairs)
&lt;&#x2F;span&gt;&lt;span&gt;  foldl(
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; make sure that you&amp;#39;re not overwriting the list of edges of a node as you
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; update it. This check makes `gen-directed-graph` slow approx 4n.
&lt;&#x2F;span&gt;&lt;span&gt;  lambda pair: add-adjacent-node(g, first(pair), second(pair))
&lt;&#x2F;span&gt;&lt;span&gt;  g
&lt;&#x2F;span&gt;&lt;span&gt;  list-of-pairs)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;g&lt;&#x2F;strong&gt;: a graph&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;list-of-pairs&lt;&#x2F;strong&gt;: a list of pairs&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The reason for the bad performance of &lt;code&gt;gen-directed-graph&lt;&#x2F;code&gt; is that it checks to
avoid overwriting any existing nodes.
This is to mean that if there&#x27;s a relationship like:
&lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; and &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt;
we have to make sure not to lose the edge &lt;code&gt;a -&amp;gt; b&lt;&#x2F;code&gt; when creating &lt;code&gt;a -&amp;gt; c&lt;&#x2F;code&gt;.
It, however, does suffice for virus data.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;3-return-a-variation-graph&quot;&gt;3. Return a Variation Graph&lt;&#x2F;h2&gt;
&lt;p&gt;A composition of &lt;code&gt;gen-node-list&lt;&#x2F;code&gt; and &lt;code&gt;gen-directed-graph&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;gen-vg(reference, variations)
&lt;&#x2F;span&gt;&lt;span&gt;  node-list &amp;lt;- gen-node-list(reference, variation)
&lt;&#x2F;span&gt;&lt;span&gt;  graph     &amp;lt;- gen-directed-graph(node-list)
&lt;&#x2F;span&gt;&lt;span&gt;  return graph
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;visualization-and-output&quot;&gt;Visualization and Output&lt;&#x2F;h1&gt;
&lt;p&gt;Graphite supports the generation of graphs in:
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;GFA-spec&#x2F;GFA-spec&quot;&gt;GFA&lt;&#x2F;a&gt;, for interoperability with tools such as &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&quot;&gt;vg&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;rrwick.github.io&#x2F;Bandage&#x2F;&quot;&gt;bandage&lt;&#x2F;a&gt;;
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DOT_(graph_description_language)&quot;&gt;DOT&lt;&#x2F;a&gt;, for visualization; and a serialized form, .gra.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;optimization-idea&quot;&gt;Optimization Idea&lt;&#x2F;h1&gt;
&lt;p&gt;Representing the alphabet in 4 bits, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;biod&#x2F;BioD&#x2F;blob&#x2F;57c81f275faab5cdec4746bfc7af81e31bac0f69&#x2F;bio&#x2F;core&#x2F;base.d#L64&quot;&gt;as is done in BioD&lt;&#x2F;a&gt;, because:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;the extra bits accommodate ambiguous bases&lt;&#x2F;li&gt;
&lt;li&gt;we could then perform fast and efficient complimenting though bit shifting&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The alphabet would be:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A as 0001&lt;&#x2F;li&gt;
&lt;li&gt;C as 0010&lt;&#x2F;li&gt;
&lt;li&gt;T as 0100&lt;&#x2F;li&gt;
&lt;li&gt;G as 1000&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;However, most of the optimization would come from graph creation, graph
update and search which is what I&#x27;m focused on for now.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>An Introduction to Variation Graphs</title>
		<published>2019-06-22T00:00:00+00:00</published>
		<updated>2019-06-22T00:00:00+00:00</updated>
		<link href="https://njagi.me/posts/introduction-to-variation-graphs/" type="text/html"/>
		<id>https://njagi.me/posts/introduction-to-variation-graphs/</id>
		<content type="html">&lt;p&gt;I expect the audience of this post to be both programmers and biologists so I&#x27;ll
bring you up to speed on a topic before going into it.
Feel free to skip a sentence, paragraph or even section if you&#x27;re familiar with a topic.&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h2 id=&quot;genome-sequencing&quot;&gt;Genome sequencing&lt;&#x2F;h2&gt;
&lt;p&gt;A &lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Genome&quot;&gt;genome&lt;&#x2F;a&gt;&lt;&#x2F;strong&gt; is the entire genetic code of an organism. While computational data
is  represented in binary form, ones, and zeros, biochemical data is represented
by nitrogenous &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Base_(chemistry)&quot;&gt;bases&lt;&#x2F;a&gt; that seem to stick out of a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;DNA&quot;&gt;DNA&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;RNA&quot;&gt;RNA&lt;&#x2F;a&gt; molecule&#x2F;strand
abbreviated A, T, C, and G for DNA and A, G, C and U for RNA.
We care about RNA because some viruses have RNA and not
DNA.&lt;&#x2F;p&gt;
&lt;p&gt;If this is confusing, you can think of a strand of DNA or RNA as a thread  with
knots where each knot is a base.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;strong&gt;sequence&lt;&#x2F;strong&gt; is an &lt;em&gt;ordering&lt;&#x2F;em&gt; of something.
A programming analog is a sequence vs a collection. Sequences are ordered,
for example lists, and therefore have the potential for a &lt;em&gt;next&lt;&#x2F;em&gt; and a &lt;em&gt;previous&lt;&#x2F;em&gt;
element while collections are just data thrown together, for example, a
dictionary or a set.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Genome sequencing&lt;&#x2F;strong&gt; (or sequencing a genome) therefore, is determining the
order of bases in all of the DNA or RNA in an organism. What makes this easy is
that all the cells in an individual organism have the same DNA so we can
get all the DNA in an organism from a single cell.
In practice, however, we can&#x27;t work with a single cell due to its size.
Ignore chromosomes, haplotypes and other things you may know about DNA for now.&lt;&#x2F;p&gt;
&lt;p&gt;To determine the sequence of bases in an entire genome of an organism we focus
on only one of the alleles (a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Haplotype&quot;&gt;haplotype&lt;&#x2F;a&gt;) and only one strand of the
double helix.
Since 2005 we&#x27;ve used methods broadly categorized
under &lt;strong&gt;Next Generation Sequencing (NGS)&lt;&#x2F;strong&gt; to perform genome sequencing.
There are two main ways of performing NGS:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Shear the DNA into small fragments, sequence those and try to build back the
original sequence. An analogy that’s used is shredding a newspaper article
then trying to recreate it.&lt;&#x2F;li&gt;
&lt;li&gt;Run the DNA strand like a train would run through a tunnel through a pore
and read the sequence of bases.
There are other methods of reading entire strands of DNA but they don&#x27;t matter
in this context.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;As you would expect, each method has its drawbacks and advantages.
What we get out of the machine that does the actual sequencing of DNA is called
a read and reads have to be &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequence_alignment&quot;&gt;aligned&lt;&#x2F;a&gt; and
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Sequence_assembly&quot;&gt;assembled&lt;&#x2F;a&gt;&lt;sup&gt;2&lt;&#x2F;sup&gt;.
Alignment involves stacking reads on top of each other and assembling is the
greater process that involves alignment, algorithmically choosing the best
alignment and determining what the original sequence was.&lt;&#x2F;p&gt;
&lt;p&gt;There are two broad categories of assembly&lt;sup&gt;4&lt;&#x2F;sup&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;De-novo assembly:&lt;&#x2F;strong&gt; this is where we sequence a genome that has never been
sequenced before&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Mapping assembly:&lt;&#x2F;strong&gt; this is sequencing an organism’s unique code despite
having the general sequence for the species. What you get from services
like &lt;a href=&quot;https:&#x2F;&#x2F;www.23andme.com&#x2F;en-int&#x2F;&quot;&gt;23andMe&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;the-reference-genome&quot;&gt;The reference genome&lt;&#x2F;h2&gt;
&lt;p&gt;A &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Reference_genome&quot;&gt;reference genome&lt;&#x2F;a&gt; is a consensus sequence that accepted as the genome of a
species&lt;sup&gt;2&lt;&#x2F;sup&gt;. It’s stored as one long sequence of characters&#x2F;bases.
You may wonder how we can have a known genome of an entire species when every
individual has a unique genetic code or how &lt;a href=&quot;https:&#x2F;&#x2F;www.scientificamerican.com&#x2F;article&#x2F;tiny-genetic-differences-between-humans-and-other-primates-pervade-the-genome&#x2F;&quot;&gt;humans are 99% chimp&lt;&#x2F;a&gt;.
Well, the answer is that genetic code of most organisms
is similar and this similarity increases as we narrow down taxonomically.
When we say that &lt;a href=&quot;https:&#x2F;&#x2F;www.scientificamerican.com&#x2F;article&#x2F;tiny-genetic-differences-between-humans-and-other-primates-pervade-the-genome&#x2F;&quot;&gt;a human is closer to a chimp than a monkey&lt;&#x2F;a&gt; what we mean is
that we can observe greater variation between the genomes of the two, man+chimp vs monkey, than man vs chimp alone.&lt;&#x2F;p&gt;
&lt;p&gt;This isn&#x27;t actual math but may help clear things up.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#002b36;color:#839496;&quot;&gt;&lt;code&gt;&lt;span&gt;variation(combine_genomes(man, chimp), monkey) &amp;gt; variation(man, chimp)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;variation-in-genomes&quot;&gt;Variation in genomes&lt;&#x2F;h1&gt;
&lt;p&gt;However, there are still genomic differences and they should not be ignored.
&lt;em&gt;The ignoring of differences is implicit in a linear reference.&lt;&#x2F;em&gt;
A better way to describe them is to say that the differences are segregating within the population.
We may also want to carry out a comparison between species or between related
species which is done in &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Pan-genome&quot;&gt;pangenomics&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;DNA has sections which are identical between individuals (conserved regions), and
the number of these  sections grow as we narrow down taxonomically and there are
sections which vary between individuals, for example, the short sequence repeats
that are compared in paternity testing.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graph_theory&quot;&gt;Graph theory&lt;&#x2F;a&gt; is an area in math that can help us understand variable
regions within genomes. The idea of representing genomes as graphs isn’t new,
however, the low number of tools like &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;vgteam&#x2F;vg&quot;&gt;vg&lt;&#x2F;a&gt; which apply graph theory to genomics
and the little that we know about genomes has been a drawback.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;graphs&quot;&gt;Graphs&lt;&#x2F;h1&gt;
&lt;p&gt;A &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graph_theory&quot;&gt;graph&lt;&#x2F;a&gt; is a series of vertices (also known as nodes) and edges.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;all_graphs.png&quot; alt=&quot;all graphs&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For genome graphs, we focus on directed acyclic graphs.
A &lt;strong&gt;walk&lt;&#x2F;strong&gt; in a directed graph is traversal from one node to another through an
edge, for example, &lt;em&gt;a&lt;&#x2F;em&gt; to &lt;em&gt;b&lt;&#x2F;em&gt; to &lt;em&gt;d&lt;&#x2F;em&gt; or &lt;em&gt;a&lt;&#x2F;em&gt; to &lt;em&gt;c&lt;&#x2F;em&gt; to &lt;em&gt;d&lt;&#x2F;em&gt;.
&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;directed_graph.png&quot; alt=&quot;directed graph&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-current-state-of-affairs&quot;&gt;The current state of affairs&lt;&#x2F;h1&gt;
&lt;p&gt;Once the reference genome of an organism has been determined, it is stored in
&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;FASTA_format&quot;&gt;fasta format&lt;&#x2F;a&gt; which contains the sequence and metadata. Moving forward, anyone
sequencing the same species aligns against this reference. Differences that occur
in less than 1% of the reads are usually thrown out;
the ones that aren’t thrown out don’t help to update the reference but are stored
in &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Variant_Call_Format&quot;&gt;Variant Call Format (VCF)&lt;&#x2F;a&gt; which contains the variation data and their
positions plus metadata. These VCF files are spread out amongst researchers and
aid in the particular thing being researched but generally don’t contribute in
and of themselves to the general genomic body of knowledge.
However, every once in awhile the reference is updated but not on a fixed
schedule&lt;sup&gt;2&lt;&#x2F;sup&gt;.
It’s for this reason that the variation graph would be a good way of
representing the reference. There is research that confirmed that short
reads align better to the variation graph than to a linear reference&lt;sup&gt;3&lt;&#x2F;sup&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;graphs-and-genomes&quot;&gt;Graphs and genomes&lt;&#x2F;h1&gt;
&lt;p&gt;Graphs that are applied to genomes are generally called &lt;strong&gt;genome graphs&lt;&#x2F;strong&gt;.
However, there are two more specific categories which are sequence graphs and
variation graphs.&lt;&#x2F;p&gt;
&lt;p&gt;As an example assume that we zoom on a hypothetical reference: &lt;strong&gt;&amp;quot;ACTGAATTTGTA&amp;quot;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Variation&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Position&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Alternative&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Variation1&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;2&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;GGGA&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Variation2&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;4&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;C&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;We could recursively insert Variation1 at position 2 and Variation2 at position
4 to generate the graph below:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;Content&#x2F;Graphs&#x2F;example.png&quot; alt=&quot;sequence graph&quot; &#x2F;&gt;
(generated using &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;graphite&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graph&quot;&gt;my current fork of graph&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;In this case, a single walk would represent a possible genome. Compared to the
reference, this variation information is maintained and the graph still holds
the data that was in reference.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sequence-graphs&quot;&gt;Sequence Graphs&lt;&#x2F;h2&gt;
&lt;p&gt;These are graphs with sequence labels on the nodes or edges.&lt;&#x2F;p&gt;
&lt;p&gt;Sequence graphs or equivalent structures have been used previously to represent
multiple sequences that contain shared differences or ambiguities in a single
structure. Related structures used in genome assembly which collapse long
repeated sequences, so the same nodes are used for different regions of the
genome include the &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;De_Bruijn_graph&quot;&gt;De Bruijn graph&lt;&#x2F;a&gt;&lt;sup&gt;5&lt;&#x2F;sup&gt;. Graphs to represent genetic variation
have previously been used for microbial genomes &amp;amp; localized regions of the human
genome such as the major &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Histocompatibility&quot;&gt;histocompatibility&lt;&#x2F;a&gt; complex.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variation-graphs&quot;&gt;Variation Graphs&lt;&#x2F;h2&gt;
&lt;p&gt;A variation graph is a sequence graph together with a set of paths representing
possible sequences from a population. However, what makes it so unique is it&#x27;s
tight mapping between the graph and the reference.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;variation-graphs-and-rsv&quot;&gt;Variation graphs and RSV&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Human_orthopneumovirus&quot;&gt;Human orthopneumovirus&lt;&#x2F;a&gt;, formerly known as Respiratory Syncytial Virus (RSV),
is a single-stranded RNA virus and a good candidate for exploration using the
variation graph because viruses don’t have proofreading in their genetic code.
Proofreading is a process in which the cell ensures that it has copied the
genetic code correctly in preparation for cell division. Without proofreading,
errors will be commonplace leading to high mutation rates.
Another advantage is the size of its genome; the reference stands at
15,206 bases which translate to 15206 bytes or 14.8 KB of memory.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;generating-a-variation-graph&quot;&gt;Generating a variation graph&lt;&#x2F;h1&gt;
&lt;p&gt;As of writing this, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;urbanslug&#x2F;graphite&quot;&gt;graphite&lt;&#x2F;a&gt; can’t generate a graph out of reads alone
(perform an alignment). It supports a reference in fasta and a single VCF file.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll detail the algorithm in a &lt;a href=&quot;&#x2F;posts&#x2F;2019-07-15-Creating-the-Initial-Variation-Graph.html&quot;&gt;later post&lt;&#x2F;a&gt; but the gist of it is this:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Load the reference into memory or read a chunk of it if you wish&lt;&#x2F;li&gt;
&lt;li&gt;Load your variation data from a VCF&lt;&#x2F;li&gt;
&lt;li&gt;Organize variations into structs containing
&lt;ul&gt;
&lt;li&gt;variation&lt;&#x2F;li&gt;
&lt;li&gt;position&lt;&#x2F;li&gt;
&lt;li&gt;reference&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Sort the variations in ascending order by position&lt;&#x2F;li&gt;
&lt;li&gt;Using a right fold function - for support of streams
&lt;ol&gt;
&lt;li&gt;fold through the list of variations&lt;&#x2F;li&gt;
&lt;li&gt;At each variation position split the reference and create a list of:
&lt;ul&gt;
&lt;li&gt;the string to the left&lt;&#x2F;li&gt;
&lt;li&gt;string to the right&lt;&#x2F;li&gt;
&lt;li&gt;a list of the variation and the base that was there originally (this will be a list of lists)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Create directed graph out of the list of lists generated by the fold
* &lt;code&gt;&#x27;((a b) (a c)) to become a node with edges from a to b and c to be and a-&amp;gt;b and a-&amp;gt;b&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;variation&quot;&gt;Variation&lt;&#x2F;h2&gt;
&lt;p&gt;A variation is a struct of &lt;code&gt;position&lt;&#x2F;code&gt; and &lt;code&gt;sequence&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I’m using the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stchang&#x2F;graph&quot;&gt;racket graph library graph&lt;&#x2F;a&gt; to generate a graph out of the nested
lists and treating the graph as a “dynamic tree”.&lt;&#x2F;p&gt;
&lt;p&gt;We then rely on graph to generate an unweighted directed graph through
&lt;a href=&quot;https:&#x2F;&#x2F;docs.racket-lang.org&#x2F;graph&#x2F;index.html#%28def._%28%28lib._graph%2Fmain..rkt%29._unweighted-graph%2Fdirected%29%29&quot;&gt;unweighted-graph&#x2F;directed&lt;&#x2F;a&gt;.
We export the graph in dot format and visualize via &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Graphviz&quot;&gt;graphviz&lt;&#x2F;a&gt;. Serialization isn’t implemented yet.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;references&quot;&gt;References&lt;&#x2F;h1&gt;
&lt;ol&gt;
&lt;li&gt;Adam M. Novak, Erik Garrison, Benedict Paten A graph extension of the positional burrows-wheeler transform and its applications bioRxiv 051409; doi: https:&#x2F;&#x2F;doi.org&#x2F;10.1101&#x2F;051409&lt;&#x2F;li&gt;
&lt;li&gt;Church DM, Schneider VA, Graves T, Auger K, Cunningham F, Bouk N, et al. (2011) Modernizing Reference Genome Assemblies. PLoS Biol 9(7): e1001091. https:&#x2F;&#x2F;doi.org&#x2F;10.1371&#x2F;journal.pbio.1001091&lt;&#x2F;li&gt;
&lt;li&gt;Garrison, Erik &amp;amp; Sirén, Jouni &amp;amp; M Novak, Adam &amp;amp; Hickey et al. (2018). Variation graph toolkit improves read mapping by representing genetic variation in the reference. Nature Biotechnology. 36. 10.1038&#x2F;nbt.4227&lt;&#x2F;li&gt;
&lt;li&gt;Wolf, Beat. &amp;quot;De novo genome assembly versus mapping to a reference genome&amp;quot; (PDF). University of Applied Sciences Western Switzerland. Retrieved 6 April 2019.&lt;&#x2F;li&gt;
&lt;li&gt;Holley, Guillaume &amp;amp; Peterlongo, Pierre. (2012). BLASTGRAPH: Intensive approximate pattern matching in sequence graphs and de-Bruijn graphs. Proceedings of the Prague Stringology Conference, PSC 2012.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
</feed>
